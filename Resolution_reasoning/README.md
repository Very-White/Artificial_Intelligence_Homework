# README 文档

## 项目概述

本项目实现了一个基于归结推理（Resolution-based Inference）的逻辑推理系统。代码通过读取初始子句集（Clause Set）S0，然后逐层生成新的子句集Sn，直到出现空子句（NIL）为止，表示推理完成。

## 功能描述

1. **读取初始子句集**：使用`ReadData.read_data`函数从指定文件（如'Block World'）中读取初始子句集S0。
> **子句集格式：**
>
> 1. 每个子句应由一个或多个谓词（即表示关系或属性的函数）及其参数（即变量或常量）组成。
> 2. 子句中的谓词可以是肯定形式（如`GradStudent(sue)`）或否定形式（如`¬GradStudent(x)`），其中`¬`表示逻辑“非”。
> 3. 变量（如`x`）用于表示不确定的个体，而常量（如`sue`）用于表示特定的个体。
> 4. 子句单独成行。
> 5. 在表示逻辑“与”（AND）关系时，可以将多个谓词放在同一个括号内，如`(¬GradStudent(x), Student(x))`。这意味着只有当`¬GradStudent(x)`和`Student(x)`同时成立时，整个子句才为真。
> 6. 子句集可以包含任意数量的子句。
2. **预处理**：通过`reasoning.preHandle`函数对初始子句集进行预处理，准备后续的推理过程。
3. **归结推理**：在`reasoning`模块中，实现了归结推理的核心逻辑。通过逐层生成新的子句集Sn，并不断与之前的子句集进行比较和归结，直到出现空子句为止。
4. **记录推理过程**：在推理过程中，使用`reasoning.record`字典记录每个生成子句的来源（母式）。这有助于后续的回溯和解释推理过程。
5. **回溯推理过程**：通过`look_back`函数，可以回溯并打印出整个推理过程。这对于理解和验证推理结果的正确性非常有用。

## 运行流程

1. 导入必要的模块：`ReadData`和`reasoning`。
2. 使用`ReadData.read_data`函数读取初始子句集S0，并进行预处理。
3. 初始化一个空列表`levels`，将预处理后的S0作为第一层子句集加入其中。同时初始化化`reasoning`的`record`字典，记录初始条件
4. 进入主循环，不断生成新的子句集Sn，直到出现空子句为止。在每一层中，使用`reasoning.next_level`函数生成下一层的子句集，并将其添加到`levels`列表中。同时打印出当前层的子句集内容。
5. 当出现空子句或达到最大迭代次数时，退出主循环。此时`levels`列表中包含了所有生成的子句集。
6. 使用`look_back`函数回溯并打印整个推理过程。从空子句开始回溯，直到达到初始条件为止。打印每个生成子句的来源和推理路径。

## 算法
使用了广度搜索，容易产生推理爆炸的情况。可以用支撑集算法改进。优点是一定可以找到满足条件的解