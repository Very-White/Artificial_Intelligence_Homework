# A* 和IDA*算法介绍
   Search.py中的算法介绍包含了两个启发式算法：A* 算法和IDA* 算法。介绍如下：
## A*算法

A*算法是一种静态路网中求解最短路径最有效的直接搜索算法。它结合了广度优先搜索和最佳优先搜索的特点，通过评估函数来引导搜索方向，从而提高搜索效率。

### 评估函数

A*算法的核心在于评估函数`f(n)`，它表示从起点经过节点`n`到达终点的估计成本。`f(n)`由两部分组成：

- `g(n)`：从起点到节点`n`的实际成本。
- `h(n)`：从节点`n`到终点的启发式估计成本（也称为启发式函数）。

评估函数 `f(n) = g(n) + h(n)`

### 启发式函数

启发式函数`h(n)`的选择对A*算法的性能有很大影响。常见的启发式函数有以下几种：

1. 欧几里得距离：适用于允许对角移动的网格地图，计算方式为两点之间的直线距离。
2. 曼哈顿距离：适用于只允许上下左右移动的网格地图，计算方式为两点在水平和垂直方向上的距离之和。



## IDA*算法

IDA*（Iterative Deepening A*）算法可以看作是深度优先搜索的一个拓展，结合了A*算法的评估函数特点。它通过不断增加深度限制来逐步逼近最短路径。



IDA* 算法通过不断增加深度限制来避免A* 算法中可能出现的空间爆炸问题，并且在某些情况下可能比A*
算法更高效。然而，它也继承了深度优先搜索的缺点，即可能会陷入深度较大的搜索树中而无法及时找到最短路径。因此，在实际应用中需要根据具体场景和需求选择合适的搜索算法。
# Search.py中的算法实现：
## A* 搜索算法
### 主要函数

- `a_star_search(start)`: 该函数接受一个起点，并返回从起点到终点的最短路径的实际成本（`cost_so_far`）和路径重构信息（`come_from`）。

### 算法步骤

1. 将起点放入优先队列，并在哈希表`cost_so_far`中记录到起点的实际成本。
2. 若队列非空则循环：取出优先队列中`f(n)`最小的结点`a`。
    - 如果`a`为终点，则结束循环。
    - 否则对其的每个相邻结点进行以下操作：
        1. 计算到该节点的实际成本，为到节点`a`的实际成本加上节点`a`转移到该相邻节点的成本`w`。
        2. 在`cost_so_far`中查找该相邻节点。
            - 如果找到且`w`比记录的实际成本更低，则替换`cost_so_far`中记录的实际成本。
            - 否则计算下一个相邻节点。
        3. 计算该相邻节点的`f(n)`，并加入优先队列当中。
        4. 在`come_from`表中将该相邻节点的前一个结点置为`a`。
    
## IDA* 搜索算法

IDA*（Iterative Deepening A*）搜索算法是A*算法的一个变种，它使用深度限制来避免A*算法中可能出现的空间爆炸问题。IDA*算法通过不断增加深度限制来逐步逼近最短路径。

### 主要函数

- `iterative_deepening_a_star_search(start)`: 该函数接受一个起点，并返回从起点到终点的最短路径的实际成本（`cost_so_far`）和路径重构信息（`come_from`）。
- `IDA_star_helper(...)`: 这是一个辅助函数，用于递归地执行IDA*搜索。

### 算法步骤

1. 从深度为0开始搜索。
2. 从起点开始，依次对相邻的每个点进行以下操作：
   - 计算点的评估函数的值并进行判断：
      - 如果大于深度限制或者`cost_so_far`中已经存在该节点且其评估函数值小于当前计算值，则返回`False`。
      - 否则更新`cost_so_far`和`cost_so_far`中的值
        - 如果找到了终点，则返回`True`
        - 否则对该点的相邻点继续搜索。如果找到了，则返回`True`,否则返回`False`
    
3. 如果在当前深度限制下没找到终点，则增加深度限制并重复步骤2。

## 路径重构

在找到最短路径后，可以通过`trace_back`函数从终点回溯到起点来重构整个路径。

### 主要函数

- `trace_back(come_from)`: 该函数接受路径重构信息（`come_from`），并返回从起点到终点的完整路径。

> 注意：在`trace_back`函数中，`goals`应该是一个变量名错误，它应该是`goal`（没有's'）。你可能需要修改这个错误才能正确运行代码。
# graph.py 文件说明

`graph.py` 包含了用于解决滑块拼图（Sliding Puzzle）问题的多个函数和数据结构。

## 主要函数和功能：

1. **`neighbours(current)`**:  
这个函数接受一个当前状态（`current`）作为输入，并返回该状态的所有相邻状态。相邻状态是通过将空格（0）与上下左右的块交换来生成的。
2. **`print_graph(graph_to_print)`**:  
一个简单的函数，用于打印给定的滑块拼图状态。它按行遍历矩阵并打印每一行。
3. **`heuristic(current)`**:  
启发式函数，用于估计从当前状态到目标状态的代价。这里使用的是曼哈顿距离加上对线性冲突的惩罚。线性冲突是指一个块阻挡了另一个块到达其目标位置的路径。
4. **`to_str(graph_to_transform)`**:  
这个函数将滑块拼图状态转换为字符串形式，方便进行比较和哈希操作。

此外，文件还定义了一些常量（如`graph_size`和`goal`）以及一个哈希映射（`hash_map`），用于快速查找每个数字在其目标状态中的位置。

推荐的视频和文章：
1. https://blog.csdn.net/wuyzh39/article/details/130072858 这个博客解释了启发式函数选用线性冲突+曼哈顿距离背后的原理
2. https://www.bilibili.com/video/BV1bv411y79P/?spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=a72ba0205e5decee94fccb8c6b66a1e2 这个视频对A*算法做了很好的解释